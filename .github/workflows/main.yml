name: Bot Doctor (å…¨é“¾è·¯ä½“æ£€ Pro)

on:
  schedule:
    - cron: '30 * * * *' # æ¯å°æ—¶çš„ç¬¬30åˆ†é’Ÿè¿è¡Œ
  workflow_dispatch: # å…è®¸æ‰‹åŠ¨ç‚¹å‡»è¿è¡Œ

jobs:
  full_body_check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: npm install axios xml2js

      # ğŸ› ï¸ ç¬¬ä¸€æ­¥ï¼šç”Ÿæˆä½“æ£€è„šæœ¬
      - name: Create Diagnosis Script
        run: |
          cat << 'EOF' > doctor.js
          const axios = require("axios");
          const xml2js = require("xml2js");
          const fs = require("fs");

          const API_URL = process.env.API_URL;
          const TIMEOUT = 30000; 

          // ğŸ”‘ã€ä¿®å¤ç‚¹1ã€‘ä½¿ç”¨ä½ çš„ç®¡ç†å‘˜IDï¼Œé¿å¼€æ¯æ—¥30æ¬¡é™æµ
          // è¿™ä¸ªIDæ˜¯ä»ä½ ä¸Šä¼ çš„ consts.js é‡Œæå–çš„
          const ADMIN_ID = "o4UNGw6r9OL9q_4jRAfed_jnvXh8";

          async function testFeature(featureName, command, expectedKeywords) {
            console.log(`\n----------------------------------------`);
            console.log(`ğŸ©º [æ£€æµ‹]: ${featureName}`);
            
            const payload = `
              <xml>
                <ToUserName><![CDATA[gh_monitor]]></ToUserName>
                <FromUserName><![CDATA[${ADMIN_ID}]]></FromUserName> 
                <CreateTime>${Math.floor(Date.now() / 1000)}</CreateTime>
                <MsgType><![CDATA[text]]></MsgType>
                <Content><![CDATA[${command}]]></Content>
              </xml>
            `;

            try {
              const res = await axios.post(API_URL, payload, {
                headers: { "Content-Type": "text/xml" },
                timeout: TIMEOUT
              });

              if (res.status !== 200) throw new Error(`HTTP ${res.status}`);

              const parser = new xml2js.Parser({ explicitArray: false });
              const result = await parser.parseStringPromise(res.data);
              const reply = (result && result.xml && result.xml.Content) ? result.xml.Content : "";

              // éªŒè¯å…³é”®è¯
              const passed = expectedKeywords.some(k => reply.includes(k));
              
              if (passed) {
                console.log(`âœ… [é€šè¿‡]`);
                return true;
              } else {
                console.error(`âŒ [å¤±è´¥] å›å¤ä¸åŒ¹é…`);
                // æ‰“å°å…³é”®ä¿¡æ¯ç”¨äºè°ƒè¯•
                console.log("å›å¤æ‘˜è¦:", reply.replace(/\n/g, " ").substring(0, 100));
                return false;
              }
            } catch (err) {
              console.error(`ğŸš‘ [é”™è¯¯] ${err.message}`);
              return false;
            }
          }

          (async () => {
            console.log("ğŸ¥ ä½“æ£€å¼€å§‹...");
            if (!API_URL) {
              console.error("âŒ æœªé…ç½® API_URL");
              process.exit(1);
            }

            const failedItems = [];

            // 1. æµ‹æŸ¥ä»·
            if (!await testFeature("ä»·æ ¼æŸ¥è¯¢", "ä»·æ ¼ å¾®ä¿¡", ["ä»·æ ¼", "å…è´¹", "å†…è´­"])) {
              failedItems.push("æŸ¥ä»·æœåŠ¡");
            }

            // 2. æµ‹æ¦œå•
            if (!await testFeature("æ¦œå•è·å–", "æ¦œå• ç¾å›½", ["1ã€", "1.", "Top 10"])) {
              failedItems.push("æ¦œå•æœåŠ¡");
            }

            // 3. æµ‹ç³»ç»Ÿæ›´æ–°
            if (!await testFeature("ç³»ç»Ÿæ›´æ–°", "ç³»ç»Ÿæ›´æ–°", ["iOS", "ç‰ˆæœ¬", "iPadOS"])) {
              failedItems.push("æ›´æ–°æœåŠ¡");
            }

            if (failedItems.length > 0) {
              const summary = failedItems.join(" + ") + " å¼‚å¸¸";
              console.error(`\nâŒ ä½“æ£€ä¸é€šè¿‡: ${summary}`);
              
              // ğŸ”‘ã€ä¿®å¤ç‚¹2ã€‘å¯¹é”™è¯¯ä¿¡æ¯è¿›è¡Œ URL ç¼–ç ï¼Œé˜²æ­¢ curl æŠ¥é”™
              // ä¾‹å¦‚ "æŸ¥ä»· å¼‚å¸¸" ä¼šå˜æˆ "%E6%9F%A5%E4%BB%B7%20%E5%BC%82%E5%B8%B8"
              const encodedError = encodeURIComponent(summary);
              
              try {
                fs.appendFileSync(process.env.GITHUB_OUTPUT, `fail_summary=${encodedError}\n`);
              } catch (e) { console.error("å†™å…¥ Output å¤±è´¥", e); }
              
              process.exit(1);
            } else {
              console.log(`\nğŸ‰ æ‰€æœ‰åŠŸèƒ½æ­£å¸¸`);
              process.exit(0);
            }
          })();
          EOF

      # ğŸš€ ç¬¬äºŒæ­¥ï¼šæ‰§è¡Œä½“æ£€
      - name: Run Diagnosis
        id: diagnosis
        env:
          API_URL: 'https://apple.290935.xyz/api/wechat'
        run: node doctor.js

      # âŒ å¤±è´¥æŠ¥è­¦
      - name: Bark Notification (Failure)
        if: failure()
        run: |
          ERROR_MSG="${{ steps.diagnosis.outputs.fail_summary }}"
          if [ -z "$ERROR_MSG" ]; then ERROR_MSG="æœªçŸ¥é”™è¯¯"; fi
          
          # ç›´æ¥å‘é€ï¼Œå› ä¸º ERROR_MSG å·²ç»åœ¨ä¸Šä¸€æ­¥ç¼–ç è¿‡äº†ï¼Œcurl ä¸ä¼šå†æŠ¥é”™
          curl "https://api.day.app/${{ secrets.BARK_KEY }}/âŒä½“æ£€æŒ‚äº†/${ERROR_MSG}?group=BotDoctor&icon=https://github.githubassets.com/favicons/favicon-failure.svg&level=critical"
