name: Bot Doctor (å…¨é“¾è·¯ä½“æ£€ Pro)

on:
  schedule:
    - cron: '30 * * * *' # æ¯å°æ—¶çš„ç¬¬30åˆ†é’Ÿè¿è¡Œ
  workflow_dispatch: # å…è®¸æ‰‹åŠ¨ç‚¹å‡»è¿è¡Œ

jobs:
  full_body_check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: npm install axios xml2js

      # ğŸ› ï¸ ç¬¬ä¸€æ­¥ï¼šç”Ÿæˆä½“æ£€è„šæœ¬
      - name: Create Diagnosis Script
        run: |
          cat << 'EOF' > doctor.js
          const axios = require("axios");
          const xml2js = require("xml2js");
          const fs = require("fs"); // å¼•å…¥æ–‡ä»¶æ¨¡å—ï¼Œç”¨äºä¼ å‚ç»™ Bark

          const API_URL = process.env.API_URL;
          const TIMEOUT = 30000; 

          // è¾…åŠ©å‡½æ•°ï¼šæµ‹è¯•å•ä¸ªåŠŸèƒ½
          async function testFeature(featureName, command, expectedKeywords) {
            console.log(`\n----------------------------------------`);
            console.log(`ğŸ©º [æ£€æµ‹]: ${featureName}`);
            
            const payload = `
              <xml>
                <ToUserName><![CDATA[gh_monitor]]></ToUserName>
                <FromUserName><![CDATA[doctor_bot]]></FromUserName>
                <CreateTime>${Math.floor(Date.now() / 1000)}</CreateTime>
                <MsgType><![CDATA[text]]></MsgType>
                <Content><![CDATA[${command}]]></Content>
              </xml>
            `;

            try {
              const res = await axios.post(API_URL, payload, {
                headers: { "Content-Type": "text/xml" },
                timeout: TIMEOUT
              });

              if (res.status !== 200) throw new Error(`HTTP ${res.status}`);

              const parser = new xml2js.Parser({ explicitArray: false });
              const result = await parser.parseStringPromise(res.data);
              const reply = (result && result.xml && result.xml.Content) ? result.xml.Content : "";

              // éªŒè¯å…³é”®è¯
              const passed = expectedKeywords.some(k => reply.includes(k));
              
              if (passed) {
                console.log(`âœ… [é€šè¿‡]`);
                return true;
              } else {
                console.error(`âŒ [å¤±è´¥] å›å¤ä¸åŒ¹é…`);
                // æ‰“å°å‰100ä¸ªå­—ç¬¦ç”¨äºè°ƒè¯•
                console.log("å›å¤æ‘˜è¦:", reply.replace(/\n/g, " ").substring(0, 100));
                return false;
              }
            } catch (err) {
              console.error(`ğŸš‘ [é”™è¯¯] ${err.message}`);
              return false;
            }
          }

          // --- ä¸»æµç¨‹ ---
          (async () => {
            console.log("ğŸ¥ ä½“æ£€å¼€å§‹...");
            if (!API_URL) {
              console.error("âŒ æœªé…ç½® API_URL");
              process.exit(1);
            }

            const failedItems = []; // ğŸ“ è®°å½•å¤±è´¥çš„é¡¹ç›®

            // 1. æµ‹æŸ¥ä»·
            if (!await testFeature("ä»·æ ¼æŸ¥è¯¢", "ä»·æ ¼ å¾®ä¿¡", ["ä»·æ ¼", "å…è´¹", "å†…è´­"])) {
              failedItems.push("æŸ¥ä»·æœåŠ¡");
            }

            // 2. æµ‹æ¦œå•
            if (!await testFeature("æ¦œå•è·å–", "æ¦œå• ç¾å›½", ["1ã€", "1.", "Top 10"])) {
              failedItems.push("æ¦œå•æœåŠ¡");
            }

            // 3. æµ‹ç³»ç»Ÿæ›´æ–°
            if (!await testFeature("ç³»ç»Ÿæ›´æ–°", "ç³»ç»Ÿæ›´æ–°", ["iOS", "ç‰ˆæœ¬", "iPadOS"])) {
              failedItems.push("æ›´æ–°æœåŠ¡");
            }

            // --- ç»“è®ºåˆ¤å®š ---
            if (failedItems.length > 0) {
              const summary = failedItems.join(" + ") + " å¼‚å¸¸";
              console.error(`\nâŒ ä½“æ£€ä¸é€šè¿‡: ${summary}`);
              
              // å…³é”®æ“ä½œï¼šæŠŠé”™è¯¯ä¿¡æ¯å†™å…¥ GitHub çš„ç¯å¢ƒå˜é‡ï¼Œä¼ ç»™ä¸‹ä¸€æ­¥
              try {
                fs.appendFileSync(process.env.GITHUB_OUTPUT, `fail_summary=${summary}\n`);
              } catch (e) { console.error("å†™å…¥ Output å¤±è´¥", e); }
              
              process.exit(1); // æ ‡è®°å¤±è´¥ï¼Œè§¦å‘ Bark é€šçŸ¥
            } else {
              console.log(`\nğŸ‰ æ‰€æœ‰åŠŸèƒ½æ­£å¸¸`);
              process.exit(0);
            }
          })();
          EOF

      # ğŸš€ ç¬¬äºŒæ­¥ï¼šæ‰§è¡Œä½“æ£€
      - name: Run Diagnosis
        id: diagnosis  # âš ï¸ å¿…é¡»æœ‰è¿™ä¸ª IDï¼Œä¸‹ä¸€æ­¥æ‰èƒ½å¼•ç”¨å®ƒçš„è¾“å‡º
        env:
          API_URL: 'https://apple.290935.xyz/api/wechat'
        run: node doctor.js

      # âŒ å¤±è´¥æŠ¥è­¦ (åŠ¨æ€å†…å®¹)
      - name: Bark Notification (Failure)
        if: failure()
        run: |
          # è·å–ä¸Šä¸€æ­¥ä¼ è¿‡æ¥çš„é”™è¯¯æ‘˜è¦ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤ºâ€œæœªçŸ¥é”™è¯¯â€
          ERROR_MSG="${{ steps.diagnosis.outputs.fail_summary }}"
          if [ -z "$ERROR_MSG" ]; then ERROR_MSG="è„šæœ¬å´©æºƒæˆ–æœªçŸ¥é”™è¯¯"; fi
          
          # å‘é€é€šçŸ¥ (URL éœ€è¦ç¼–ç ï¼Œç®€å•èµ·è§æˆ‘ä»¬ç›´æ¥æ‹¼è£…ï¼ŒBark ä¼šå¤„ç†éƒ¨åˆ†å­—ç¬¦)
          curl "https://api.day.app/${{ secrets.BARK_KEY }}/âŒä½“æ£€æŒ‚äº†/${ERROR_MSG}?group=BotDoctor&icon=https://github.githubassets.com/favicons/favicon-failure.svg&level=critical"
